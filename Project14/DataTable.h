/*
Workshop 8 : STL Algorithms
Date : 11/21/2017
Filename : DataTable.h
Student Name : Samantha West
Student ID : 128111168
Description : Using standard template library algorithms to evaluate sample data.
*/
#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <iomanip>
#include <numeric>
#include <algorithm>

namespace w8 {

	template<class T>
	class DataTable {
		int fieldWidth;
		int decimals;
		std::vector<T> x; // list of x values
		std::vector<T> y; // list of y values
	public:
		DataTable() {}
		// Upon instantiation object receives a reference to file stream
		// as well as field and width data for number of dec to display.
		// Object retreives data values from file and stores them in
		// instance variables. 
		DataTable(std::ifstream &file, int f, int w)
		{
			// set objects fieldwidth and decimal point
			fieldWidth = f;
			decimals = w;

			T p1;
			T p2;
			std::string line;

			if (file.is_open()) {

				while (getline(file, line)) {

					// count line position
					int delimeter = 0;
					std::string temp1; //x temp
					std::string temp2; //y temp

									   // test line is extracting properly
									   // std::cout << line << std::endl;

									   // extract x value of pair
					for (unsigned int i = 0; i < line.size() && line[i] != ' '; i++) {
						temp1 += line[i];
						delimeter++;
					}

					// extract y value of pair
					for (unsigned int i = delimeter + 1; i < line.size() && line[i] != ' '; i++) {
						temp2 += line[i];
					}

					// add var to x vector
					p1 = stod(temp1);
					x.push_back(p1);
					// add var to y vector
					p2 = stod(temp2);
					y.push_back(p2);
				}
			}
			else {
				std::cerr << "Sorry, there was an error opening your file! Try again :)" << std::endl;
				exit(1);
			}
			file.close();
		}

		T mean() const // returns the mean value of the dependent coordinate
		{	
			T mean = std::accumulate(y.begin(), y.end(), 0.0, [&](T a, T b) {return (a + b) / y.size(); });
			return mean;
		}

		T sigma() const // returns the standard deviation of the dependent coordinates
		{
			T m = mean();
			T sum = std::accumulate(y.begin(), y.end(), 0.0, [&]() {return ((y - m) * (y - m)); });
			return std::sqrt(sum / (y.size() - 1));
		}

		T median() const // returns the median value of the dependent coordinate
		{
			std::vector<T> temp = y;
			// put all numbers in numerical order
			std::sort(temp.begin(), temp.end());
			// get middle of sorted vector
			T median = temp[temp.size() / 2];
			return median;
		}

		void regression(T& slope, T& y_intercept) const // returns the slope and intercept for the data set
		{
			T yAverage = std::accumulate(y.begin(), y.end(), 0.0) / y.size();
			T xAverage = std::accumulate(x.begin(), x.end(), 0.0) / x.size();

			T yd = std::accumulate(y.begin(), y.end(), 0.0, [&]() {return( x - xAverage) * (y - yAverage); });
			T xi = std::accumulate(y.begin(), y.end(), 0.0, [&]() {return (x - xAverage) * (x - xAverage); });

			slope = yd / xi; // slope of the line in x-y plane
			y_intercept = yAverage - (slope * xAverage); // y valye of the line where it crosses the y-axis
		}
		void display(std::ostream& os) const // displays the data pairs as shown below
		{
			std::cout << "\nData Values\n==========\n";
			os << std::setw(fieldWidth) << "x" << std::setw(fieldWidth) << "y" << std::endl;
			for (unsigned int i = 0; i < x.size(); i++) {
				os << std::setw(fieldWidth) << std::fixed << std::setprecision(decimals) <<
					x[i] << std::setw(fieldWidth) << std::fixed << std::setprecision(decimals) << y[i] << std::endl;
			}
		}

	};

	template<class T>
	std::ostream& operator<<(std::ostream& os, const DataTable<T>& d) // inserts the data generated by display() into the output stream
	{
		d.display(os);
		return os;
	}

}
